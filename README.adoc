= ORKG Backend Prototype
Manuel Prinz <manuel.prinz@tib.eu>

:icons: font

This repository contains a backend prototype for the ORKG based on the https://spring.io/[Spring Framework].
It is written in https://kotlinlang.org/[Kotlin] as a proof-of-concept and for experimenting with a possible architecture and technologies.

== Building and running

To build and run the prototype, type:

    ./gradlew bootRun

This will start a server running on http://localhost:8080.
The only available REST resource (for now) is http://localhost:8080/api/articles/.

This also requires a Blazegraph server running on http://localhost:8889/bigdata/.
It expects the SumSur ontology to be loaded into the triple-store.
See the instructions below.

== Docker images

=== Building the images

To build all Docker images (that contain the service dependencies), run:

    ./gradlew docker

If you want to build only specific images, either

[loweralpha]
. call `./gradlew :docker/IMAGE:docker` from the project root directory, or
. go to a `docker/IMAGE` directory and call `../../gradlew docker` there,

where `IMAGE` is the name of a sub-directory under `docker/`.

=== Running the images

The easiest way to start Docker containers from the images is via https://docs.docker.com/compose/[Docker Compose].
After installing it, run:

    docker-compose -f docker/IMAGE/docker-compose.yml up -d

where `IMAGE` is the name of a sub-directory under `docker/`.

The images will provide the following end-points:

[cols=2*,options=header]
|===
|Image
|End-points

|`orkg/blazegraph-dev`
|http://localhost:8889/bigdata/

|`orkg/neo4j-dev`
| http://localhost:7474/browser/ +
bolt://localhost:7687

|===

=== Uploading data

In order to be useful, you need to import data into Blazegraph.
This has to be done manually.
Download the file `SemSur_3-labels.owl` from the https://git.tib.eu/orkg/orkg-ontology[`orkg-ontology` repository] and upload it to Blazegraph using the http://localhost:8889/bigdata/#update["Update" tab].

== Features

Not much, to be honest. Particularly,

* a single REST resource, and
* a repository that queries a Blazegraph server using SPARQL.

An implementation of the `ArticleRepository` for Blazegraph is done.
One for Neo4j will follow.
(The idea is to explore how to implement vendor-independent data models and a clean architecture.)
